\documentclass[11pt]{article}
\usepackage{graphicx} % This lets you include figures
\usepackage{hyperref} % This lets you make links to web locations
\usepackage[margin=0.5in]{geometry}
\usepackage[rightcaption]{sidecap}
\usepackage{subcaption}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{imakeidx}
\usepackage{indentfirst}
\makeindex
%---------------------------Do Not Edit Anything Above This Line!!------------------------

% edit the line below, if needed, to change the directory name for your image files.
\graphicspath{ {./images/} }



\begin{document}

%---------------------------Edit Content in the Box to Create the Title Page--------------
\begin{titlepage}
   \begin{center}
       \vspace*{1cm}
	   \Huge
       \textbf{CDN Music App}

       \vspace{0.5cm}
       \Large
       Project 2 \\
       9/29/2025 \\
   \end{center}

       \vspace{1.5cm}

\begin{table}[h!]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Name} & \textbf{Email Address} \\ \hline
Aaron Downing         & aaron.downing652@topper.wku.edu         \\ \hline
Ryerson Brower         & ryerson.brower178@topper.wku.edu         \\ \hline
\end{tabular}
\end{table}

%Latex Table Generator    
%https://www.tablesgenerator.com/     
        
\vspace{4in}

\centering        
CS 396 \\
Fall 2025\\
Project Technical Documentation

\end{titlepage}
%---------------------------Edit Content in the Box to Create the Title Page--------------


% No text here.


%---------------------------Do Not Edit Anything In This Box!!------------------------
%Table of contents and list of figures will be autogenerated by this section.
\newpage
\setcounter{page}{1}%
\cleardoublepage
\pagenumbering{gobble}
\tableofcontents
\cleardoublepage
\pagenumbering{arabic}
\clearpage
\newpage
\setcounter{page}{1}%
\cleardoublepage
\pagenumbering{gobble}
\listoffigures
\cleardoublepage
\pagenumbering{arabic}
\newpage
%---------------------------Do Not Edit Anything In This Box!!------------------------




%---------------------------Project Introduction Section------------------------------

% No text here.

\section{Introduction} %\section{} is used to create major section headers

% No text here.

%---------------------------Project Overview------------------------------------------
\subsection{Project Overview} %\subsection{} is used to create minor sections 
% 300 words
% Description of the project, what the project provides, its purpose, problems solved, and target audience.

The Content Delivery Network (CDN) Implementation project is designed to enhance the performance, scalability, and reliability of a music streaming and download service by caching audio content at multiple geographically distributed edge locations. By leveraging edge caching, the system reduces latency, improves download speeds, and provides a seamless user experience for streaming music, even during peak usage periods. The primary objective is to ensure that users can access audio files quickly and efficiently, regardless of their location or device, while the backend intelligently manages routing, caching, and content delivery.

The system architecture was developed using Node.js for the backend, which provides efficient server-side processing, request handling, and real-time updates to cached content. The frontend was built using HTML, CSS, and JavaScript, creating a responsive and intuitive user interface where users can easily find, stream, and download music. Together, this technology stack ensures a fast, scalable, and user-friendly experience.

Functionally, the CDN caches music files in multiple formats (MP3, AAC, OGG) at edge servers to maximize compatibility with diverse devices and playback applications. Requests are routed intelligently based on a user’s geographical location and network conditions, ensuring minimal streaming latency. Real-time updates allow new releases and content changes to propagate quickly, guaranteeing that users always have access to the latest music. The system also incorporates analytics to track streaming quality, download speeds, and user interactions, providing administrators with actionable insights.

Non-functional requirements focus on ensuring response times under 100 milliseconds, scalability through the addition of edge servers, and industry-standard security protocols such as encryption and authentication. The system also emphasizes seamless usability with clear feedback and error handling. With built-in monitoring and analytics, the CDN can be continuously optimized for performance and efficiency, making it a robust solution for large-scale music distribution.


%---------------------------End Project Overview---------------------------------------

% No text here.

%---------------------------Project Scope----------------------------------------------
\subsection{Project Scope}
% 350 words
% Description of all deliverables, benefits, outcomes, and work required (all tasks, costs, time, people, resources, dates/deadlines, and final deliverables date).

Text goes here.

%---------------------------End Project Scope---------------------------------------

% No text here.


\subsection{Technical Requirements}


%---------------------------Functional Requirements----------------------------------------------
\subsubsection{Functional Requirements} %\subsubsection{} used to create sections for parent subsections.
% Functional requirements define what a system or software must do, specifying the desired behavior or functionality.

% List as atomic bullet points that can be tested

\begin{table}[h!]
\centering
\begin{tabular}{|l|}
\hline
\textbf{Mandatory Functional Requirements} \\ \hline
1. The CDN must cache audio files at edge locations to minimize latency for users accessing the music streaming \\ or download service. Cached content should include various formats and qualities to accommodate different user  \\ preferences.                                      \\ \hline
2. The system must intelligently route requests to the nearest edge location based on user geographical location \\ and network conditions to ensure optimal performance during music streaming or downloads.                                      \\ \hline
3. The CDN must support real-time content updates, allowing new music releases or changes to existing files \\ to be propagated quickly across edge locations, ensuring that users always access the latest content.                                      \\ \hline
4. The CDN must be capable of serving audio files in multiple formats (e.g., MP3, AAC, OGG) to accommodate \\ various devices and playback requirements, ensuring compatibility with a wide range of
client applications.                                           \\ \hline
5. The system must provide analytics features that track user interactions, streaming quality, and download speeds, \\ allowing administrators to monitor performance and make data-driven improvements.                                           \\ \hline
\textbf{Extended Functional Requirements}  \\ \hline
1. The CDN must provide users with the ability to adjust playback options, such as play, pause, and skip, \\ during streaming.                                 \\ \hline
2. The system must provide users with the option to download songs for offline playback in supported formats.                                 \\ \hline
3. The CDN must allow users to view recently played or downloaded songs for quick access.                               \\ \hline
                                           \\ \hline
                                           \\ \hline
\end{tabular}
\end{table}

% Paragraph (150 words) explaining the need and purpose for the listed Functional Requirements.
The functional requirements of the CDN music application define the core capabilities the system should provide to deliver music efficiently and effectively to users. The CDN is designed to cache audio files at multiple edge servers, reducing latency and improving performance for both streaming and downloads. Requests are routed to the nearest edge location, ensuring that users receive the fastest possible access based on their geographic location and network conditions. The system also supports real-time updates, so new released and modified files are released across the network. Guaranteeing users always have access to the most up-to-date content. Additionally, the CDN serves audio in multiple formats such as MP3, AAC, and OGG to support a wide range of devices and applications. Users can also download songs for offline playback, access recently played or downloaded content, and control playback with basic options such as play, pause, and skip during streaming.


%---------------------------End Functional Requirements----------------------------------------------

% No text here.

%---------------------------Non-Functional Requirements----------------------------------------------
\subsubsection{Non-Functional Requirements}
% Non-functional requirements specify the constraints, qualities, or attributes that the system or software must possess, such as performance, security, usability, portability, fault tolerance, or reliability.

% List as atomic bullet points that can be tested

\begin{table}[h!]
\centering
\begin{tabular}{|l|}
\hline
\textbf{Mandatory Non-Functional Requirements} \\ \hline
1. The CDN must ensure that the average response time for streaming and download requests is under 100  \\ milliseconds, even during peak usage periods, to provide a seamless user experience.                                      \\ \hline
2. The system must be designed to handle an increasing number of simultaneous users and requests without  \\ performance degradation, allowing for the addition of new edge servers as user demand grows.                                      \\ \hline
3. The system must implement industry-standard security protocols to protect user data and audio content, \\ including encryption of data in transit and robust authentication mechanisms to prevent unauthorized access.                                      \\ \hline
4. The CDN must provide a seamless and intuitive user experience, ensuring that users can easily find, stream, \\ and download music with minimal steps and without confusion, supported by clear feedback and error messaging \\ throughout the process.                                           \\ \hline
5. The system must provide real-time monitoring and analytics capabilities, allowing administrators to \\ track performance metrics, user interactions, and content delivery efficiency, facilitating ongoing optimization \\ and troubleshooting.                                           \\ \hline
\textbf{Extended Non-Functional Requirements}  \\ \hline
1. The system must maintain an uptime of at least 99 percent to ensure high availability of the music \\ streaming and download service.                                 \\ \hline
2. The system must maintain error rates (e.g., failed requests) below 1 percent to ensure a consistent and reliable \\ user experience.                                 \\ \hline
3. The CDN must be designed with a responsive user interface so that the service works smoothly on desktops                                 \\ \hline
                                           \\ \hline
                                           \\ \hline
\end{tabular}
\end{table}

% Paragraph (150 words) explaining the need and purpose for the listed Non-Functional Requirements.
The non-functional requirements of the CDN project establish the quality standards and operational goals that ensure the system’s efficiency, scalability, and reliability. The CDN must provide a fast and seamless experience, maintaining response times under 100 milliseconds, even during peak traffic. Availability is a priority, with the system expected to maintain 99.9 percent uptime, while reliability is ensured by keeping request error rates below 1 percent. Scalability is supported by a design that allows the easy addition of new edge servers as user demand grows. The system also emphasizes security, implementing encryption for data in transit and robust authentication to protect both users and audio content. From a usability perspective, the user interface is designed to be responsive across desktops, tablets, and mobile devices, ensuring accessibility for all. Finally, administrators benefit from real-time monitoring and analytics to track performance, optimize delivery, and troubleshoot issues efficiently.


%---------------------------End Non-Functional Requirements---------------------------------------

% No text here.



%---------------------------DevOps - Continuous Delivery Approach and Results-------------------------------------------------

\section{DevOps - Continuous Integration and Continuous Delivery Approach and Results}
%describe your set of practices that enable you to release software quickly, safely, and sustainably by automating the software delivery process, resulting in faster time to market, improved software quality, and enhanced team productivity.

The approach we took for our CI and CD we setting up GIT Actions. This really helped us be able to test our files the moment they are updated and see if there is any errors. We leverage GitHub Actions to implement our CI workflow, which automatically triggers a series of vital steps upon every code push. This includes running a fast build process and executing automated unit tests and integration tests. Automating these checks allows us to catch errors and conflicts early, significantly reducing the cost and complexity of fixing issues later in the development cycle. The immediate feedback loop established by Git Actions ensures code quality remains high, making the entire release process inherently safer. Our CD practice focuses on creating a reliable, repeatable path to production. The same automated pipeline used for testing will also handle the process of packaging the application and preparing it for release to staging or production environments. This standardization removes human error and guarantees consistency across deployments, making releases safer and more predictable. This highly reliable, automated process is the primary driver for achieving a faster time to market for new music content and CDN features.

%---------------------------End DevOps - Continuous Delivery Approach and Results-------------------------------------------------



%---------------------------DevOps - Architecture Approach, Models, and Results-------------------------------------------------

\section{DevOps - Architecture Approach, Models, and Results}
%describe how you designed systems with loosely coupled components, allowing you to work independently, deploy frequently, and scale efficiently, ultimately enabling rapid delivery of software and system reliability.

Our CDN project is designed with a loosely coupled architectural approach, where distinct functional components are logically separated. This modular design is the backbone of our ability to work independently, deploy new features frequently, and ensure efficient system scaling while maintaining high reliability. This strategy ultimately enables the rapid delivery of software value. The Content Origin: The source of truth for audio files (the music directory). Its sole purpose is content storage and serving, decoupled from the delivery logic. The Delivery and Routing Layer: This component, simulated by our Edge Cache and Geo-Routing logic in server.js, handles all user interactions. It independently manages caching decisions, routing, and time-to-live (TTL) updates. The Analytic and Monitoring Service: This block autonomously tracks performance metrics (latency, cache hits) via the /analytic endpoint, ensuring that data gathering is separate from content delivery. The independence of these components drives our operational efficiency. Because the routing logic is decoupled from the content storage, we can update the caching algorithm or geo-routing function without requiring a re-deployment or extensive re-testing of the entire Origin content library. This isolation enables frequent and safer deployments.


%---------------------------End DevOps - Architecture Approach, Models, and Results-------------------------------------------------



% No text here.

%---------------------------DevOps - Product and Process Approach and Results-------------------------------------------------

\section{DevOps - Product and Process Approach and Results}
%describe your focus on creating customer-centric, feedback-driven development processes that integrate cross-functional teams, enabling continuous improvement and alignment between product development and business outcomes.




%---------------------------End DevOps - Product and Process Approach and Results-------------------------------------------------

% No text here.


%---------------------------DevOps - Product Management and Monitoring Approach and Results-------------------------------------------------

\section{DevOps - Product Management and Monitoring Approach and Results}
%describe how you implemented proactive, data-driven monitoring and feedback systems that provide real-time insights into system performance, enabling you to identify issues early, improve decision-making, and optimize both system stability and team performance.




%---------------------------End DevOps - Product Management and Monitoring Approach and Results-------------------------------------------------


% No text here.

%---------------------------Product DevOps - Cultural Approach and Results-------------------------------------------------

\section{DevOps - Cultural Approach and Results}
%describe how your team created a collaborative, trust-based environment that emphasizes shared responsibility, continuous learning, and experimentation, driving high performance and innovation.




%---------------------------End DevOps - Cultural Approach and Results-------------------------------------------------


% No text here.

%---------------------------Software Product Testing Section-------------------------------------
\section{Software Testing and Results}



%---------------------------Software Testing Plan Template-------------------------------------

\subsection{Software Testing Plan Template}
%Each of the testing levels (unit, Integration, System, Acceptance) should use the following test plan template.

\textbf{Test Plan Identifier:} %Provides a unique identifier for the test. Every test should have a unique identification number for reference.

\textbf{Introduction:} % 50 words. Brief description and objective about the test type.

\textbf{Test item:} %50 words. Includes detailed information about the Software Under Test (SUT).

\textbf{Features to test/not to test:} %50 words. In scope features. This could be newly added or updated features. Out of scope features not tested. [Provide reasoning for exclusion, like, non-impacted, low priority, etc.]

\textbf{Approach:} %50 words. Strategy to test the software. Includes types of tests and how to test. Functional, performance, security testing using combined [manual + automation], manual only, automation only approach.

\textbf{Test deliverables:} %50 words. All the deliverables from the testing e.g. approaches, test cases, reports etc.

\textbf{Item pass/fail criteria:} %50 words. Entry and Exit criteria for all items. 

\textbf{Environmental needs:} %50 words. Infrastructure required for SUT and executing test cases.

\textbf{Responsibilities:} %50 words. Roles and responsibilities for various testing / supported activities.

\textbf{Staffing and training needs:} %50 words. Training needs to bridge the gap of available and expected skill.

\textbf{Schedule:} %50 words.  Test schedule should also be noted in the Gantt Chart. Test estimation (Efforts) and high-level schedule. Schedule should be for key deliverables or important milestones. Ideally, all test deliverables included in the test plan should be scheduled.

\textbf{Risks and Mitigation:} %100 words. Risk identification for applicable items, assumptions, and mitigation plan.

\textbf{Approvals:} %Approvals and sign of dates.

%---------------------------Software Testing Plan Template-------------------------------------





%---------------------------End Software Product Testing Section-------------------------------------


% No text here.



%---------------------------Conclusion Section-------------------------------------
\section{Conclusion}
%200 words
%Concluding remarks that summarizes the purpose and outcomes of the technical document.  Discussion of short comings and future work.
In conclusion this project went a bit smoother than the first project we did. This may be because we jumped on it a lot faster than the other. We were able to get the hardest part which was the coding done pretty fast. One thing that we could have improved on was the way we implemented the Music App. We not to sure how to make a complete network for the music app so we only used a local host. Similarly for the edge systems we only simulated it with our code that gave us the response time and the predicted edge system, such as New York, Asia, and more. We downloaded two songs, a longer song (around 7 mins) and a shorter song (around 3 mins). Some thing we didn't know how to implement was the ability to download and upload song remotely. So there was a lot we wished we could have polished out but we had to keep our scope pretty small to complete this project. But overall thanks to this project brought a lot of light to what DevOps was and how to use it to our advantage. We will be able to use these skills in the future. 
%---------------------------End Conclusion Section-------------------------------------


% No text here.



%---------------------------Appendix Section-------------------------------------------
\section{Appendix}

\subsection{Software Product Build Instructions}
%Include in this section all steps for copying the current state of the product to new computers for continued development.
Text goes here.

\subsection{Software Product User Guide}
%Include in this section an overview guide on how to use your software product for a general user and an administrative user.
Text goes here.

\subsection{Source Code with Comments}
%Include in this section all final source code for the product.  Label each file with headings such as, C.1 file1.c, C.2 file2.c, C.3 file1.py, etc.  All source code should be effectively commented.
Text goes here.







%---------------------------End Appendix Section-------------------------------------------














%example image:  uncomment to show usage
%\begin{figure}[h]
%    \centering
%    \includegraphics[width=1\textwidth]{images/Add_non-music.png}
%    \caption{This is how you add non-music items.}
%    \label{fig16}
%\end{figure}


%example links:  uncomment to show usage.
%\url{https://www.youtube.com}
%\href{https://www.wku.edu/}{WKU Homepage}
%\footnote{You can put the link in a footnote like this.}

% Anything to the right of a percent sign will be ignored by LaTeX.
% You can use this to put notes to yourself.  



\end{document}
